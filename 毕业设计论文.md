#毕业设计论文
基于LBS的老年医疗服务WebApp设计与开发
## 第二章 WebGIS基础与前后端应用技术
### 2.1 WebGIS技术
#### 2.1.1WebGIS概念
WebGIS是指通过互联网对地理空间数据进行采集、编辑、发布、共享进一步产生应用，以实现空间数据的共享和交互操作，具体使用例子如在线地图，在线地形分析等等。WebGIS与以往的常规GIS系统不同在于采用了B/S模式，用户使用常见的浏览器如Chrome、Safari、360浏览器等等进行相关操作，无需安装专业软件，使得专业化技术性功能实现起来更方便。顾名思义，WebGIS是借助Web这一平台来实现GIS相关功能的技术，通过网站与网页的方式来实现借助浏览器来管理，操作，发布和应用空闲信息的功能。WebGIS可以通过多种方式来进行部署，实现形式多样。
#### 2.1.2WebGIS原理
从名字上来看，WebGIS只是搭载环境由本地转为了Web平台，实现的功能与原有的GIS软件并没有太多的区别，因为现在Web服务器与本地客户端(浏览器)的计算能力越来越强，原本大强度的计算已经可以满足；它的优点在于解决了早期GIS软件网络相关功能的缺失，能够更好地进行实时的交互，信息的交换更为方便，使用条件更低，而它的基础就是Web相关基础技术。
WebGIS将常见的浏览器作为客户端，用户通过发送相关请求来获取后端服务器上的普通信息与地理信息数据库中的地理信息文件来实现相关功能。后端返回的内容可以分为两种，一种是直接将查询到的数据返回到客户端，另外一种是将渲染好的页面发送给客户端。与此同时地理信息文件也可以分为多种类型，例如数据型，栅格图片型，矢量图片型等。
#### 2.1.3WebGIS实现形式
主要有 3 种 WebGIS 体系结构模式： 
1.基于服务器端的模式。这种情况下无论是数据的获取还是相关的计算都由后端服务器来进行，当后端服务器完成数据获取和计算操作后将最终的结果以图片的形式或矢量图SVG或Canvas画布形式传达到用户的浏览器中，此时浏览器只是作为展示工具而不进行相关的实现。
2.基于客户端的模式。当采用这种模式时当用户需要某些GIS数据时就会向后端服务器发起请求，服务器接收到请求后会将数据返回到浏览器中，浏览器通过自身的计算能力来进行相关操作，这对浏览器的性能和用户自己的计算机性能有一定的要求，所以一般只是进行简单的数据操作，操作完成后将结果展示给用户。 
3.分布式模式。这种模式相比较前者而言更为符合我们平时的使用要求，对于复杂的功能比如地形分析，相关性分析，插值等都由服务器来进行操作只返回最终的结果；而简单的操作比如地图的展示，拖动，查询，简单编辑等则由浏览器本身来进行实现。基于这样的操作形式使得服务器与客户端(浏览器)都得以物尽其用，充分发挥了两者的功能，同时之所以能实现这样的变化是因为浏览器的不断发展和完善，能实现的功能与计算能力越来越强大。
#### 2.1.4HTML5 GeoLocation功能介绍
HTML5在设计之初就公开了Geolocation相关API接口，它可以借助用户硬件设备和网络信息来获取当前位置，使用获取的位置可以进行一些进一步相关的操作。Geolocation的位置信息来源包括GPS、IP地址、RFID、WIFI和蓝牙的MAC地址、以及GSM/CDMS的ID等等。规范中没有规定使用这些设备的先后顺序，在HTML5的实现中，手机等移动设备优先使用GPS定位，而笔记本和部分平板，最准的定位是WIFI，至于网线上网的台式机，一般就只能使用IP来定位了，这个准确度最低。
HTML5本身提供的方法并不是十分便捷的，所以我自己进行了封装并以此来说明具体该如何使用HTML5的这一新特性：

``` js
    var geo = {
        //检查浏览器是否支持Geolocation功能
        checkGeo: function() {
            if (navigator.geolocation) {
                return true
            } else {
                alert('浏览器该更新了~');
                return false
            }
        },
        // 获取地理位置信息
        getPosition: function(){
        	var that = this;
        	navigator.geolocation.getCurrentPosition(that.successFun,that.errorFun);
        },
        successFun: function(position){
        	var coords = position.coords;
        	var lng = coords.longitude;
        	var lat = coords.latitude;
        	var pos = {
        		lng:lng,//精度
        		lat:lat//纬度
        	}
            return pos;
        },
        errorFun: function(error){
        	alert(error.msg);
        }
    }
```

#### 2.1.5 高德地图JavaScript API介绍
高德地图是国内知名的地图服务供应商之一，其提供的JavaScript API暴露了很多可以由客户端直接发起访问的应用程序接口，比如基本的地图显示，漫游缩放、标记点的相关临近搜索、出行路线规划、添加标记、实时路况等功能，与此同时我们可以基于已有的功能进行二次开发，比如重载地图点击事件，调整标记点的显示内容等。高德官方提供了完整且详细的使用指南及示例中心，在开发过程中随时可以进行查阅和了解，具体的使用方法在第三章中会进行介绍。
----以上已修改过一次------


### 2.2前端核心技术
#### 2.2.1 HTML
HTML是网站的脊梁，它是构建一切网页和网站的基础超文本标记语言。HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计令人赏心悦目的网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。
HTML元素是构建网站的基石。HTML允许嵌入各种多媒体，并且可以用于创建交互式表单，通过具有语义化的标签包裹相应的内容来实现信息的结构化。html以尖括号来定义标签，同时大部分标签都成对使用，标签内包裹具体的内容。
HTML可以嵌入如JavaScript的脚本语言，它们会影响HTML网页的行为。网页浏览器也可以引用层叠样式表（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织万维网联盟（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素。
近几年来，随着 Web 开发标准版本的不断更新 HTML5 也被提出并得到了
广泛的应用。和以往的 Web 开发标准不同，它是完成了标准化历史的一次飞跃，
HTML5 除了用来表示 Web 内容，他的另一个任务是实现包括视频、声音、图片等在内网络资源标准化交互。
HTML5 新内容有以下几方面(但不限于)：
**语义特性**
HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。
**本地存储特性**
HTML5提出了LocalStorage和SessionStorage两种本地数据存储形式，这相较于之前的cookie机制和session机制而言可以为WebApp提供更多的存储空间实现更高的性能，也不必每次都将相关的信息发送到服务器去导致资源的浪费，这是HTML5更新的最重要的技术之一。
**设备兼容特性**
HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势，现在浏览器也能调用很多原本只有原生APP才能调用的接口，例如Geolocation功能也可以调用移动设备本身的GPS模块，这相比较之前而言定位精度的提升是十分明显的，HTML5提供了前所未有的数据与应用接入开放接口。
**连接特性**
WebSockets API被提出后使得基于网页的IM实时通讯功能的实现变得尤为简单，这就级高了连接的工作效率，需要持续连接的相关服务都得以优化，实时推送功能也不在局限于原生应用，HTML5拥有更有效的服务器推送技术，借助Server-Sent Event就可以实现相关的功能。
#### 2.2.2 CSS
CSS（Cascading Style Sheets，级联样式表）是用来实现如何将我们想表达的内容通过更合理的布局和设计来展现给网站浏览者的一种标记性语言，我们给HTML中的元素设置不同的样式属性使得他们能按照我们想要的效果来展示。它具有以下几个突出优点：内容和表现相互分离；使网页浏览速度得到提高；维护和改版简便。
CSS1.0（最早的 CSS 版本）只支持最基础的 HTML 标签元素，CSS2 添加了对媒介（打印机和听觉设备）和可下载字体的支持，随着前端模块化开发的流行，CSS3 语言也向模块化方向发展，CSS3 把之前版本的 CSS 分解成一些较小的模块，同时也加入了更多新的诸如盒模型、列表、文字特效等模块。
CSS3 使网页开发者不必再用图片处理软件或者 JavaScript 脚本控制去完成3D 动画、圆角、用户自定义字体、多背景、盒阴影、渐变、文字阴影、透明度，从而使 Web 设计质量大有提高更具特色。
#### 2.2.3 JavaScript
JavaScript，一种直译式脚本语言，是一种动态类型、基于原型的语言，内置支持类。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。然而现在JavaScript也可被用于网络服务器，如Node.js。
一般来说，完整的JavaScript包括以下几个部分：
	•	ECMAScript，描述了该语言的语法和基本对象
	•	文档对象模型（DOM），描述处理网页内容的方法和接口
	•	浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口
它的基本特点如下：
	•	是一种解释性脚本语言（代码不进行预编译）
	•	主要用来向HTML页面添加交互行为
	•	可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离
JavaScript常用来完成以下任务：
	•	嵌入动态文本于HTML页面
	•	对浏览器事件作出响应
	•	读写HTML元素
	•	在数据被提交到服务器之前验证数据
	•	检测访客的浏览器信息
	•	控制cookies，包括创建和修改等
### 2.3 WebApp介绍
#### 2.3.1Web2.0
Web2.0 是相对于Web1.0 的新的时代。指的是一个利用Web的平台，通过了解用户想要获得的体验来进行网站的相关开发，这里更多的考虑用户的需求点是什么，而不是盲目的进行信息的展示和传递，为了区别传统由站长或编辑人员来决定要展示什么给用户的网站类型而定义为第二代互联网，即web2.0。
Web 2.0是一种新的互联网方式，通过网络应用（Web Applications）促进网络上人与人间的信息交换和协同合作，其模式更加以用户为中心。典型的Web 2.0站点有：实时通信IM，博客，维基百科，地理服务应用，社交网站等等。
Web 2.0的支持者认为Web正在由最一开始的展示性传播性功能向交互性与社会性发生转变，用户更多的是想表达自己的观点而不是单纯的获取相关的资讯和新闻。某种观点认为，和传统网站相比，Web 2.0的网站更多表现为Point of presence或者是用户产生内容的门户网站。
Web2.0时代所基于的技术中有一项为LBS(Location Based Services),它是集地理信息系统（GIS）、微博（Twitter）和移动设备（Mobile）以及A-GPS定位服务于一身的增强型微博系统，这与传统的信息展示不同，它将地理信息空间要素与传统的信息相结合，既可以进行时间上的筛选和聚合，也可以根据地理要素来进行汇总，实现时空相关性分析。
#### 2.3.2 单页面应用
SPA，即Single Page Application 单页面应用，浏览器会在一开始加载必须的html，js和css，之后所有的操作都是基于这些内容，后续的操作是通过js来进行实现的，全程只有一个页面，显示内容有变化是因为进行了视图切换。
单页面应用（SPA）是旨在对Web应用发动革命的软件运动中可信度很高的一种。此类应用有望进行更加模块化的开发，令应用更加容易地适配与多个设备，并拥有更好的应用生命周期管理—这些几乎是软件架构师希望的全部。单页面应用诞生于拥有更多动态页面内容的Web 2.0革命。旧的超链接页面浏览模型给用户带来了不和谐的体验，而Web 2.0原则允许数据驱动时间在一个页面内创建，并让页面内容在需要的时候更新。
单页面应用诞生于拥有更多动态页面内容的Web 2.0革命。旧的超链接页面浏览模型给用户带来了不和谐的体验，而原则允许数据驱动时间在一个页面内创建，并让页面内容在需要的时候更新。这意味着应用似乎可以运行得更加流畅，乃至于到达可仿真桌面与本地资源接口的地步。
单页面应用优点：
	•	用户体验好、速度更快快，内容的改变不需要重新加载整个页面
	•	良好的前后端分离。由于后续只做数据请求，后端不再负责模板渲染、输出页面工作，后端API通用化，很多时候iOS/Android/H5可以共用一套API，降低了开发成本
	缺点：
	•	不利于页面SEO(搜索引擎优化) 
	•	当所有资源被压缩为一个文件后，初次加载时耗时相对增多
	•	由于是单页面应用，前进和后退就成了问题，不能使用浏览器本身的history系统
### 2.4前端辅助框架
#### 2.4.1 jQuery
**jQuery**
jQuery是一套跨浏览器的JavaScript库，目的在于简化HTML与JavaScript之间的操作。JQuery是继prototype之后又一个优秀的Javascript库。虽然功能强大但是其体积却很轻量，同时提供了压缩版的min版本以供生产环境使用。不同的浏览器间本身是存在差异的，jQuery的存在基本消除了这些差异，对常见的浏览器如IE6+、Safari、Opera、Chrome以及国内的360浏览器等都具有很好的兼容性。后期的最新版本由于功能的升级和优化所以舍弃了对低版本IE的兼容，所以在使用过程中要注意是否需要对低版本浏览器进行优化。如今, jQuery已经成为最流行的javascript库,在世界前10000个访问最多的网站中,有超过55%在使用 jQuery。正是由于使用用户众多这也就带来了一个十分显著的优点：可参考的文档及使用的插件众多，有些你想要实现的功能已经预先有人完成了实现并封装好了方法，只要学习是如何实现的相关功能就能很快的上手使用，这大大提高了开发效率，缩短了组件的开发时间。
jQuery是一个兼容多浏览器的javascript库，核心理念是write less,do more(写得更少,做得更多)。同时它是免费、开源的，使用MIT许可协议。jQuery的语法设计可以使开发更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。除此以外，jQuery提供API让开发者编写插件。开发者可以根据自己的需要对jQuery进行相关的扩展，添加相关的辅助方法或者组件，使得重交互性的网页可以被轻易地实现。
jQuery，顾名思义，也就是JavaScript和查询（Query），即是辅助JavaScript开发的库。
#### 2.4.2 Require.js
require.js的诞生是为了解决两大问题，第一实现js文件的异步加载，避免网页失去响应，第二是管理模块之间的依赖性，便于代码的编写和维护。最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序，依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。
在使用了require.js之后我们只需要在页面中引用这一个js就够了，例子如下：
`<script data-main="main.js" src="require.js"></script>`
main.js是实现模块化加载的入口，我们在其中定义了相关依赖的项，例如：

```
(function(){
    require.config({
        baseUrl:'widget',
        paths: {
            jquery:'ui/jquery/jquery-2.2.2.min',
            template:'ui/template/template',
            underscore:'ui/underscore/underscore',
            backbone:'ui/backbone/backbone',
        },
        shim: {                     
            'underscore': {
                exports: '_'
            },
            'jquery': {
                exports: '$'
            },
            'template': {
                exports: 'T'
            },
            'backbone': {
                deps: ['underscore', 'jquery'],
                exports: 'Backbone'
            }
        }
    });
    
    require(['backbone', 'underscore', 'ui/router/router'], function(){
        Backbone.history.start();   //开始监控url变化
    });
})(window);
```
baseUrl定义了模块加载的基准路径，而当我们自定义一个模块时则需要这样进行：

```
define(['backbone', 'template', 'background/count/tpls','ui/helper/helper','ui/map/map'], 
function(Backbone, T, tpls,helper,map) { 
	var obj = {
		...
		...
	};
	
	return obj;
})
```
define中可以预先说明这一模块依赖的项，并在后面的function中暴露出相应的对象以供该模块进行使用。
#### 2.4.3 Backbone
Backbone.js是一种轻量级的JavaScript库，用于将结构添加到客户端代码。它可以让应用程序的关注点管理和解耦工作变得容易，从长远来看，它可以使代码更易于维护。
开发人员通常使用像Backbone.js这样的库来创建单页面应用程序(SPA)，上文也已经提到了SPA是一种将页面加载到浏览器，然后就不需要从服务器刷新整个页面，就可以在客户端完成交互的Web应用程序。
很多现代JavaScript框架为开发人员提供使用MVC(Model-View-Controller，模型-视图-控制器)模式的辩题来轻松组织代码的方法。MVC将应用程序中关注点分为以下三个部分：
**模型**
模型(Model)代表了应用程序中的特定领域知识和数据。可以将它想象为一个可以建模的数据类型，如一个用户、一张图片或备忘录。模型在其状态发生改变时可以通知其他观察者。
**视图**
视图(View)通常用于在应用程序中构成用户界面(如标记和模板),但不是必须的。它们观察着模型，但并不与它们直接通信。
**控制器**
控制器(Controller)用于处理输入(单击或用户操作)以及更新模型。

因此，在MVC应用程序中，用户的输入受控制器的支配，而控制器更新模型。视图观察模型，并在模型发生更改时更新用户界面。然而JavaScript MVC框架并不总是严格遵守这种模式，一些解决方案将控制器的任务合并到了视图，而其他方法也混入到额外的组件中，因此更合适的称呼方式为MV\*，有其他的组件会负责完成controller的工作。
Backbone中的主要组成部分包含视图(View)、模型(Model)、集合(Collection 模型的聚合物),路由(Router)等几部分，形成了自己独特的MV\*模式。在视图和模型之间支持事件驱动的通信，在任何模型的属性上添加事件监听器、针对视图中的变化为开发者提供细粒度控制是相对简单的；Backbone只强制依赖了underscore.js这一个javascript库，其他需要的中间件或者要实现的功能都可以通过自己的需要来进行加载。
#### 2.4.4 art-Template
由于借助Backbone.js实现了SPA应用，因此页面的渲染和加载都需要由前端来进行而不是直接展示后端拼接好的页面，所以选择一个合适的前端模板是十分必要的。Backbone本身强制依赖的underscore提供了微型模板可以进行使用，但是由于语法过于粗糙且实现的功能单一，所以就开始寻找合适的前端模板。
art-template是新一代 javascript 模板引擎，它有如下一些特性：
	
	1.	性能卓越，执行速度通常是 Mustache 与 tmpl 的 20 多倍，更遑论underscore的微模板
	2.	支持运行时调试，可精确定位异常模板所在语句，便于进行调试
	3.	对 NodeJS Express 友好支持(后端选择了使用node来搭建)
	4.	安全，默认对输出进行转义、在沙箱中运行编译后的代码（Node版本可以安全执行用户上传的模板）
	5.	支持include语句，实现加载子模板
	6.	可在浏览器端实现按路径加载模板(更符合require.js要求)
	7.	支持预编译，可将模板转换成为非常精简的 js 文件
	8.	模板语句简洁，无需前缀引用数据，有简洁版本与原生语法版本可选
	9.	支持所有流行的浏览器 
### 2.5 css预编译语言
#### 2.5.1 Less
Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合(mixin)、函数等功能，让 CSS 更易维护、方便制作主题、扩充。
作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。
**作为一种动态样式语言,对比css而言有以下几点优势:**

1.嵌套规则,通过选择器名间的嵌套(包裹)来实现层次化的赋予选择器样式，这样使得样式层次清晰，增强了层次间的联系也避免了出现由于层次结构不清而导致的样式设置错误情况的出现；同时减少了代码量，在进行串联选择器的时候使用&是十分高效的，尤其是针对:hover,:selected等伪类样式的设置。

2.提供了变量的概念，可以单独定义一系列样式，在后续样式中进行使用，使得全局调整更为简便；同时提升了css语义化，在协同工作时可以通过变量名来了解前期开发者想表达的意图。

3.mixin混合(也包含了函数)，可以将已经定义好的样式引入到新的选择器中，实现了样式的继承；同时可以实现函数模式带参数进行调用，能够更好的根据需求进行修改，实现了样式代码片段的复用。

### 2.6 后端技术介绍
#### 2.6.1 Node.js
JavaScript是一种运行在浏览器的脚本，它简单，轻巧，易于编辑，这种脚本通常用于浏览器的前端编程，但是一位开发者Ryan有一天发现这种前端式的脚本语言可以运行在服务器上的时候，一场席卷全球的风暴就开始了。

Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。

Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。

node是单线程单进程的，但是在底层node其实是有进程池的。单进程主要负责对事件队列进行监听，一旦发现有事件出现就将该事件分配到底层的进程池去运行(比如I/O)操作，同时告诉进程池一个回调函数；当阻塞的事件执行完毕后会将执行结果和回调函数一同返回到事件队列，由单进程负责进行启动回调函数和后续操作的运行，node就是通过这样的事件轮询机制实现了高效的服务器(通俗的例子就像在外吃饭点餐后会给你一个叫号器,你在等待的同时就会有人在给你制作，完成后会叫你来取)但是由于回调函数中的任务还是在负责轮询的单线程中执行，这就注定了它不能执行CPU繁重的任务。
### 2.7 数据库应用技术介绍
#### 2.7.1 NoSQL
关系型数据库中的很大一部分操作都是为了保证事务的一致性(Consistency),而这也是关系型数据库的灵魂，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统；剩下的三个特性原子性(Atomicity)、隔离性(Isolation)、持久性(Durability)都是为了一致性来服务的。
但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，用户A看到的内容和用户B看到同一用户C内容更新不一致是可以容忍的，或者说，两个人看到同一好友的数据更新的时间差那么几秒是可以容忍的，因此，关系型数据库的最大特点在这里已经无用武之地，起码不是那么重要了。
相反的，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博，facebook这类SNS的应用，对并发读写能力要求极高，关系型数据库已经无法应付，因此，必须用新的一种数据结构化存储来来代替关系数据库。
而另外一个特点是关系型数据库都是具有固定的表结构的，这就使得一旦有数据结构发生改变原有的数据库就无法满足要求而需要新的存储结构来进行存储，而现如今的SNS应用中经常会有这方面的变化，这就导致关系型数据库无法很好的满足这一需求。
当代典型的关系数据库在一些数据敏感的应用中表现了糟糕的性能，例如为巨量文档创建索引、高流量网站的网页服务，以及发送流式媒体。关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或者大批量极少写访问的事务。
于是，非关系数据库（NoSQL）应运而生，它的存储结构并不一定是固定且不可变的，因此它不具备固定的表结构，从这样的意义上来说非关系型数据库更应该被称为是一种存储结构化的集合而非数据库。
NoSQL是指'Not Only SQL',即不只是数据库系统，这与传统的关系型数据库是存在本质性区别的。这两者存在许多显著的不同点，而其中最重要的是NoSQL不使用SQL作为查询语言。其数据存储可以不需要固定的表格模式，也经常会避免使用SQL的JOIN操作，一般有水平可扩展性的特征。NoSQL的实现具有二个特征：使用硬盘，或者把随机存储器作存储载体。
但是如果需要数据的持久存储，尤其是海量数据的持久存储，关系型数据库的作用还是无法被取代的，在实际的数据库运用过程中往往都是两者相辅相成的进行，各负责一部分数据存储的内容。

#### 2.7.2 mongoDB
MongoDB是一种文档导向数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。
它将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象，字段值可以包含其他文档，数组及文档数组。
mongoDB的特点如下：
		1.MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。
		2.你可以在MongoDB记录中设置任何属性的索引 (如：FirstName="Sameer",Address="8 Gandhi Road")来实现更快的排序。
		3.你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。
		4.如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。
		5.Mongo支持丰富的查询表达式。由于存储对象都是BSON格式的，所以既可以通过某一字段进行查询也可以查询内嵌的对象和数组，亦可通过正则表达式来进行查询，十分便捷。
		6.MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。
		7.MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。
		8.MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。
		9.MongoDB安装简单。

------以上已改完了两遍

## 第三章 老有所医WebApp设计与实现
### 3.1 系统整体设计
根据毕业设计初衷，最初的设计方案以及后期通过与一些中老年人进行交流对App的整体需求进行了细化，完成了对各个功能点的基本设计，基本确定了整个系统的基本架构如图3.1所示。
老有所医WebApp在总体架构上主要分三个部分：前端页面设计，后端服务器与接口设计，数据库设计。前端页面主要分两大块，分别是用户使用页面(移动端)及后台管理页面；根据需求主要分为推送文章，医疗点查询，老年活动室和个人信息四块内容，每块内容又细分若干功能。后端服务器使用node.js进行搭建，同时借助了Express框架以简化相关代码编写，使用了body-parser、mongoose、path、crypto等中间件，同时采用了类RESTful风格接口，使得数据交换更简单。数据库方面选择了NoSQL中的mongoDB来存储相关信息，mongoDB与一般的关系型数据库不同，它存储的数据格式为BSON，修改起来更为方便。
之所以选择了这样一整套技术架构是出于这样的原因：前后端包括数据库都是使用JavaScript来写的，在相互切换编写代码的过程中不需要语言的切换，使得代码编写过程更流畅，学习调研成本相对更低，效率更高。

```
这里要插入图3.1
```

### 3.2前端设计与实现
#### 3.2.1页面自适应
由于是WebApp开发所以无法避免的问题就是可能会有不计其数的屏幕尺寸出现，如何解决多设备多屏幕适配是在开发之前亟待要解决的问题。我使用的方案是：通过用户进入页面时获取当前页面尺寸，动态设置根节点html的字体号大小，同时每当页面尺寸发生变化时也重新设置根字体大小，而后续的所有元素使用rem为单位，以1080px的设计稿尺寸为基准进行动态取值，主要实现代码如下：

```
(function () {
    var completed = function () {
        setTimeout(function () {
            var RADIX = 10.8;
            var html = document.documentElement;
            var windowWidth = html.clientWidth;
            html.style.fontSize = windowWidth / RADIX + 'px';
        }, 16);
    };
    completed();
    window.onresize = completed;
})();
```
样式的实现上主要借助了less语法中的函数来实现，如下所示：

```
@radix: 100;
.px2rem(@name, @px) {
    @{name}: @px / @radix * 1rem;
}
```
这里运用到的概念为dpr，即'屏幕像素尺寸/设计稿尺寸'可以计算出屏幕上1像素相当于设计稿上的像素大小，再使用rem设置每个元素的相对尺寸，通过这样的方式可以实现针对不同的设备都显示相同效果的目的。

#### 3.2.2通用组件设计
前端界面中主要涉及的通用组件如图3.2所示。

```
这里要插入图3.2
```
**Geolocation**
第二章中对HTML5提供的Geolocation进行了简要的介绍，这里的Geolocation主要是对该方法进行了相应的封装，需要使用时只要载入该对象即可,可以实现地理位置获取及地图初始化的功能。部分功能代码如下：

```
		getPosition: function(){
        	var that = this;
			navigator.geolocation.getCurrentPosition(that.successFun,that.errorFun);
        },
        successFun: function(position){
        	var coords = position.coords;
        	var lng = coords.longitude;
        	var lat = coords.latitude;
        	var pos = {
        		lng:lng,
        		lat:lat
        	}
        	map.init(pos);
            return pos;
        },
```

**Map**
Map组件主要是对高德地图API的二次封装和调用。由于多个视图中用到了相关方法，出于优化代码量的目的将所有需要的方法都进行了提取，同时进行了对象封装，主要的方法功能有：**init** 主要负责页面地图的初始化；**initBack** 后台使用地图的初始化操作；**getMarkerPosition** 获取当前地图上标记点的坐标；**nearBySearch** 临近搜索相关功能；**walkingSearch** 步行导航与出行路线规划；**drivingSearch** 驾车导航与出行路线规划；**busSearch** 公交出行路线规划。

**Help**
Help组件主要是定义了一些通用的工具方法以便各个页面进行使用，比如实现了对localStorage判断、读/取数据的封装，**randomKey** 生成随机字符串以确保发送数据的唯一性，**queryString** 获取查询字符串等。

**Nav**
Nav组件主要是针对移动端来设计的。每个页面都需要引入底部的nav导航而如果在每一个视图中重复载入会导致底部导航的不断刷新，同时也会浪费相应资源，因此将这一部分进行了抽出，只在初次进入页面时加载一次，后续只需要根据用户点击的nav-name不同进行active切换即可。

## 参考文献
[1]  史同广,张子民,周英.WebGIS 实现模式及其技术评价[J].山
东建筑工程学院学报,2005,20(1). 
[2]  杨惠芬. 趋势科技导入MongoDB－追踪管理全球10万个行动装置，上万笔资料同时写入. ithome. 2013-01-17 [2013-01-21].

> * 第三章 老有所医WebApp设计与实现
> 		* 3.2前端模块、页面设计
> 			* 3.2.1模块设计
> 			* 3.2.2用户页面设计与实现
> 			* 3.2.3后台页面设计与实现
> 		* 3.3网站结构与require.js Backbone使用
> 			* 3.3.1网站结构
> 			* 3.3.2require.js使用
> 			* 3.3.3Backbone与art-template使用
> 		* 3.4前端页面与功能展示(用户页面与后台结合)分功能进行
> 			* ...
> 			* ...
> 		* 3.5数据库设计
> 		* 3.6后端服务器搭建与接口设计
> 			* ...
> 			* ...




